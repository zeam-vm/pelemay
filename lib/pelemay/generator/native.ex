defmodule Pelemay.Generator.Native do
  alias Pelemay.Db
  alias Pelemay.Generator
  alias Pelemay.Generator.Native.Util, as: Util

  def generate(module) do
    Pelemay.Generator.libc(module) |> write(module)
  end

  defp write(file, module) do
    str =
      init_nif()
      |> basic()
      |> generate_functions()
      |> erl_nif_init(module)

    file |> File.write(str)
  end

  defp generate_functions(str) do
    code_info = Db.get_functions() 

    Db.clear()

    definition_func =
      code_info
      |> Enum.map(&(generate_function(&1)))

    str <> Util.to_str_code(definition_func) <> func_list(definition_func)
  end

  defp generate_function([func_info]) do
    generate_function(func_info)
  end

  defp generate_function(%{module: module, function: func} = info) do
    module = Atom.to_string(module)
    func = Atom.to_string(func)

    prefix = "Pelemay.Generator.Native.#{module}.#{func}"

    {res, _} = 
      try do
        Code.eval_string("#{prefix}(info)", info: info)
      rescue
        e in UndefinedFunctionError -> 
          Map.update(info, :impl, nil, fn _ -> false end)
          |> Db.register()
          error(e)
      end
    res
  end

  defp func_list(list) do
    fl =
      Enum.zip(list, Db.get_functions())
      |> Enum.reduce(
        "",
        fn
          {nil, _}, acc ->
            acc

          {_, info}, acc ->
            str = erl_nif_func(info)
            acc <> "#{str},\n  "
        end
      )

    """
    static
    ErlNifFunc nif_funcs[] =
    {
      // {erl_function_name, erl_function_arity, c_function}
      #{fl}
    };
    """
  end

  defp erl_nif_func([%{nif_name: nif_name, arg_num: num}]) do
    ~s/{"#{nif_name}", #{num}, #{nif_name}}/
  end

  defp init_nif do
    """
    // This file was generated by Pelemay.Generator.Native
    #pragma clang diagnostic ignored "-Wnullability-completeness"
    #pragma clang diagnostic ignored "-Wnullability-extension"

    #include<stdbool.h>
    #include<erl_nif.h>
    #include<string.h>

    ERL_NIF_TERM atom_struct;
    ERL_NIF_TERM atom_range;
    ERL_NIF_TERM atom_first;
    ERL_NIF_TERM atom_last;

    static int load(ErlNifEnv *env, void **priv, ERL_NIF_TERM info);
    static void unload(ErlNifEnv *env, void *priv);
    static int reload(ErlNifEnv *env, void **priv, ERL_NIF_TERM info);
    static int upgrade(ErlNifEnv *env, void **priv, void **old_priv, ERL_NIF_TERM info);

    static int
    load(ErlNifEnv *env, void **priv, ERL_NIF_TERM info)
    {
      atom_struct = enif_make_atom(env, "__struct__");
      atom_range = enif_make_atom(env, "Elixir.Range");
      atom_first = enif_make_atom(env, "first");
      atom_last = enif_make_atom(env, "last");
      return 0;
    }

    static void
    unload(ErlNifEnv *env, void *priv)
    {
    }

    static int
    reload(ErlNifEnv *env, void **priv, ERL_NIF_TERM info)
    {
      return 0;
    }

    static int
    upgrade(ErlNifEnv *env, void **priv, void **old_priv, ERL_NIF_TERM info)
    {
      return load(env, priv, info);
    }
    """
  end

  defp erl_nif_init(str, module) do
    str <>
      """
      ERL_NIF_INIT(Elixir.#{Generator.nif_module(module)}, nif_funcs, &load, &reload, &upgrade, &unload)
      """
  end

  defp basic(str) do
    {:ok, ret} = File.read(__DIR__ <> "/native/basic.c")

    str <> ret
  end

  defp error(e) do
    IO.puts("Please write a native code of the following code: #{e.module}.#{e.function}/#{e.arity}")
    {nil, []}
  end

  # defp arithmetic(str) do
  #   str <> File.read(@dir <> "arithmetic.c")
  # end
end
